---
title: 자료구조 - 연결리스트
date: '2023-01-13'
tags: ['자료구조', 'coding test']
draft: false
---

## 🤔 연결리스트란?

연결리스트는 각 요소를 포인터로 연결하여 관리하는 선형 자료구조다.
각 요소는 노드라고 부르며 데이터 영역과 포인터영역으로 구성된다.
첫번째 노드는 Head라고 한다. 포인터는 다음 요소를 가르키고 있다.

## ✅ 연결리스트의 특징

- 메모리가 허용하는 한 요소를 제한없이 추가할 수 있다.
- 탐색은 O(n)이 소요된다.
- 요소를 추가하거나 제거할 때는 O(1)이 소요된다.
- Singly Linked List, Doubly Linked List, Circular Linked List가 존재한다.
- 단일연결리시트, 이중연결리스트, 환형연결리스트

## ✅ 배열과 리스트의 차이점

배열은 원소들이 순차적으로 메모리를 차지하고 있어서 연속적인 데이터지만, 연결 리스트는 메모리의 연속성을 가지고 있지 않아서 데이터가 여기저기 퍼져있다. 연결리스트에서 포인터의 필요성은 여기서 알 수 있다. 데이터가 연속적으로 저장되어 있지 않기 때문에, 다음 데이터가 있는 장소를 알려주는 용도로 포인터가 있는 것이다.

![image](https://user-images.githubusercontent.com/72537762/212266309-4ce35a8f-f2f6-4be4-b0e1-07052119e793.png)

## 🛠 단일연결리스트 - Singly Linked List

단일 연결리스트는 Head에서 Tail까지 단방향으로 이어지는 연결리스트를 말한다.
Tail의 포인터는 `null`로 되어 있는데, 포인터가 `null`이면 단일연결리스트의 끝을 의미한다.

![image](https://user-images.githubusercontent.com/72537762/212267525-7de17209-74ed-4856-a7d3-01f79b792ec0.png)

### 단일연결리스트 - 요소 찾기

단일 연결리스트에서 원하는 요소를 찾기 위해서는 먼저 Head부터 시작하여 차례로 포인터대로 이동하며 원하는 데이터인지 확인을 한다. 원하는 데이터를 찾게 되면 요소 찾기 로직이 종료 되고 `O(n) 선형시간`의 시간을 소요하게 된다.

### 단일연결리스트 - 요소 넣기

아래 그림처럼 요소 3을 중간에 넣기 위해서는

1. 3의 포인터에 4의 위치를 저장한다.
2. 2의 포인터에 3의 위치를 저장한다.

결과적으로 `O(1)`상수시간만큼 소요된다.

![image](https://user-images.githubusercontent.com/72537762/212268573-7ba73ef3-152a-46c8-8953-36a84206a467.png)

### 단일연결리스트 - 요소 삭제

만약 2를 삭제한다면,

1. 삭제할 요소의 이전 요소의 포인터를 삭제할 요소 다음 요소로 수정한다
2. 삭제할 요소를 메모리상에서 삭제한다.

마찬가지로 `O(1)`상수시간만큼 소요된다.

![image](https://user-images.githubusercontent.com/72537762/212268805-72f5da09-9740-407b-b79a-08ef98cbe4ec.png)

## 🛠 이중연결리스트 - Doubly Linked List

이중연결리스트는 양방향으로 이어지는 연결 리스트로 , 다음 데이터를 가르키는 포인터 뿐만 아니라 이전 데이터를 가르키는 포인터도 존재한다. 따라서 단일연결리스트보다 자료구조의 크기가 더 크다.

![image](https://user-images.githubusercontent.com/72537762/212269372-08ea4368-a8a2-40ab-8057-caf9b6bf27fa.png)

### 이중연결리스트 - 요소 추가

만약 3 요소를 추가한다고 하면

1. 3요소의 다음 노드 포인터를 4요소 주소로 추가
2. 2요소의 다음 노드 포인터를 3요소 주소로 수정
3. 4요소의 이전 노드 포인터를 3요소 주소로 수정
4. 3요소의 이전 노드 포인터를 2요소 주소로 추가

마찬가지로 `O(1)`상수시간만큼 소요된다.
![image](https://user-images.githubusercontent.com/72537762/212269554-5b225d1e-21bf-4c9b-a495-4d07d99115c1.png)

### 이중연결리스트 - 요소 삭제

만약 3 요소를 삭제한다고 하면

1. 1요소의 다음 노드 포인터를 4요소 주소로 수정
2. 4요소의 이전 노드 포인터를 1요소 주소로 수정
3. 2요소의 메모리 삭제

마찬가지로 `O(1)`상수시간만큼 소요된다.

![image](https://user-images.githubusercontent.com/72537762/212270199-93c793ef-9cc6-4269-b633-d3423870620c.png)

## 🛠 환형연결리스트 - Circular Linked List

환형연결리스트는 단일 혹은 이중연결리스트에서 Tail이 Head로 연결되는 연결리스트다.
Tail의 포인터는 어차피 `null`이므로 첫번째 요소를 가르킴으로써, 메모리를 아껴쓸 수 있다는 장점이 있다.
원형 큐를 만들때도 사용된다.

![image](https://user-images.githubusercontent.com/72537762/212270598-aab5ae06-e75e-41f2-a592-a02461b8ec83.png)

## 🧑‍💻 연결리스트 Javascript 코드

### 단일 연결리스트

```javascript
// 새로운 노드 생성
class Node {
  constructor(value) {
    this.value = value // 데이터
    this.next = null // 포인터
  }
}

class SinglyLinkedList {
  constructor() {
    this.head = null // head의 포인터
    this.tail = null // tail의 포인터
  }

  //요소 조회
  find(value) {
    let currNode = this.head // head 부터 탐색을 시작한다.
    while (currNode.value !== value) {
      // 원하는 요소를  찾을때까지 포인터 주소를 담는다
      currNode = currNode.next
    }
    return currNode
  }

  //요소 추가
  append(newValue) {
    const newNode = new Node(newValue) // 위의 노드 class로 새로운 노드 생성
    if (this.head === null) {
      // 만약 head에서 가르키는 노드가 없다면
      this.head = newNode // head의 다음 포인터로 newNode 지정
      this.tail = newNode // 마지막 요소로 newNode 지정
    } else {
      // 만약 head에서 가르키는 노드가 있다면
      this.tail.next = newNode // 마지막 요소의 다음 요소로 newNode 지정
      this.tail = newNode // 마지막 요소로 newNode 지정
    }
  }

  //요소 삽입
  insert(node, newValue) {
    const newNode = new Node(newValue) // 새로운 노드 생성
    newNode.next = node.next // newNode의 다음 요소 => 지정한 노드(삽입할 위치 이전 요소)의 다음요소
    node.next = newNode // 지정한 노드의 다음 요소는 newNode
  }

  //요소 삭제 - 순차탐색
  remove(value) {
    let prevNode = this.head // 삭제할 노드의 이전 요소를 찾기 위해 head 부터 시작
    while (prevNode.next.value !== value) {
      //삭제할 노드의 이전 요소를 찾을 때까지 루프
      prevNode = prevNode.next
    }

    if (prevNode.next !== null) {
      prevNode.next = prevNode.next.next
      // 삭제할 노드의 이전 요소를 찾으면 다음다음 노드를 가르키도록 수정한다.
      // 중간 노드가 아무런 요소와 연결되어 있지 않아서 자연스럽게 삭제된다.
    }
  }
}
```

> 참고: 프로그래머스 코딩테스트 광탈 방지 A - Z
