---
title: Javscript 호이스팅
date: '2022-12-15'
tags: ['javscript']
draft: false
---

## 1. Hoisting

Javascript는 interpreter 언어다. Interpreter 언어는 코드를 처음부터 끝까지 한줄한줄 차례대로 읽어나가는 것을 말한다.

> C,C++ 등의 프로그래밍 언어들이 complie 언어라고 하는데, complie 언어들은 한줄 한줄 처리하지 않고 작성된 코드를 모두 기계어로 변환 후에 기계에 넣고 실행한다.

Javascript 엔진은 코드를 처음부터 읽어내려가며 해석하기 전에 소스 코드를 실행 하기 위한 준비를 한다. 이 과정에서 변수 선언을 포함한 모든 `선언문`, `변수 / 함수 선언문`들을 찾아내어 먼저 실행하게 된다. 이후에 나머지 코드들을 순차적으로 읽어내려간다.

다시말해서, `선언문`들은 어느 위치에 선언이 되었던 간에 그 어떤 코드들 보다 가장 먼저 실행 된다는 것이다.(모든 선언들은 런타임 이전에 실행)

이것을 바로 `Hoisting`이라고 한다.

## 2. hoisting 예시

아래 예시에서 보면 `num` 변수가 선언 되기 이전에 console로 num을 보여주도록 했는데, num이 아직 선언이 되지 않았음에도 불구하고 에러가 나지 않고 `undefiend`라고 console에 찍히게 된다.

같은 예시로 `active` 함수가 아래에 선언되었지만 가장 맨위에서 호출이 가능하다.

이런 것들은 일반적인 다른 프로그래밍 언어에서는 있을 수 없는 일인데, 오로지 javascript에서만 에러를 뱉지 않는다고 한다.

```javascript
(...)
console.log(num) // undefinend
active()
var num = 0;

function active() {
	(...code)
}

```

## 3. hositing의 문제점

- 코드의 가독성이 떨어진다
- 유지 보수가 힘들어진다
- 디버깅이 힘들어진다(코드를 찾기 힘들어짐)
- 쓸모없는 코드가 남발될 수 있다

### ⭐️ 변수의 경우

위 예시와 같이 변수가 hoisting이 되서, 선언 전에 사용 할 수 있게 되면 변수에 할당된 데이터가 다른 곳에서 변경이 되거나 문제가 생겼을 때 찾기가 매우 어려워진다. 이 내용을 이해하기 위해서는 `var`, `let`, `const`의 차이를 알고 있어야 한다.

#### var

- 선언 하기 전에 변수명을 써도 에러가 나지 않고 undefiend으로 뜬다
- 같은 이름의 변수를 선언해도 에러가 나지 않는다
- 함수레벨 스코프로 실행 된다

> 함수레벨 스코프란 함수내에 선언된 것은 지역변수, 함수 이부에 선언된 것은 전역변수로 실행되며 그 외에 코드블럭(if, forEach, map ..etc)내에 선언된 변수는 전역변수로 취급 된다. 따라서 원하지 않게 변수가 전역 변수 처리가 되면서 오류를 뱉을 수 있는데, 이 경우 디버깅하기가 매우 힘들어진다.

### let / const 공통 특징

- 선언 하기 전에 변수명을 사용 할 수 없다
- 같은 이름의 변수를 선언 할 수 없다
- 블록레벨 스코프로 실행된다

### let

- 초기에 할당한 값이 있더라도 값을 재할당 하여 변경 할 수 있다
- ✅ 재할당은 할당되었던 공간에 있는 데이터를 지우고 교체하는 것이 아니라, 아예 새로운 메모리 공간과 주소값을 확보하여 할당하는 것이다.

### const

- 불변의 값이다. 값을 재할당 할 수 없고 변수보다는 상수개념으로 많이 사용된다.
- 데이터 값 자체는 재할당 할 수 없으나, 배열의 원소나 객체의 value 값은 변경이 가능하다.

#### var는 선언전 호출 가능, let / const는 불가능?

위의 특징들만 살펴보면 선언전에 호출이 가능 한 것은 `var` 키워드 뿐이다. 그래서 흔히들 착각하는 부분이 `let`, `const`는 hoisting이 되지 않는 다고 생각 하는 것이다. 앞서 말했듯이 Javascript 엔진은 코드를 읽어내려가기 전에 `모든 선언문`을 가장 위로 끌어올린다. 따라서 let과 const도 var와 동일하게 hoisting이 일어난다는 것이다.

그렇다면 어떻게 let과 const는 선언 전에 호출 됐을때 에러가 나지 않는가? 라는 질문에 대한 답은 `var`과 `let / const`의 `선언 단계 과정`이 달라서다. 변수의 선언단계는 기본적으로 두단계로 이루어 진다.

1. 선언단계 : 변수 이름을 등록해서 Javascript 엔진에 변수의 존재를 알린다.
2. 초기화단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefiend를 할당해 초기화 한다.

✅ **var**
위의 두 단계를 `var`키워드는 동시에 실행한다. 따라서 Javascript 엔진이 선언문을 hoisting 했을시 이미 `var`로 선언된 변수는 초기화 단계까지 마친 상태기 때문에, 선언 이전에 호출을 해도 에러가 나지 않고, 값을 할당하지 않은 초기화 상태로 불려지는 것이다.

✅ **let / const**
`let`과 `const`는 위 두 단계가 동시에 일어나지 않고, 선언단계 이후에 초기화 단계가 실행된다. 즉, Javascript 엔진이 let / const를 선언문으로 인식하여 hoising을 해도 변수에 초기화단계가 실행되지 않았기 때문에 메모리 공간이 아예 확보되지 않은 상태인 것이다. 따라서 let / const 변수를 선언하기 전에 해당 변수를 호출하면 할당된 메모리 공간 자체가 없기 때문에 변수에 접근 할 수 없게 되고 에러가 발생한다.

### ⭐️ 함수의 경우

함수의 호이스팅을 막기 위해서는 위에서 설명 된 `let`,`const`를 활용하면 된다. 함수 자체가 다시 재할당 되는 일은 거의 없으므로 const를 주로 사용 하게 된다. `const`를 사용 하여 함수를 변수에 할당하게 되면 함수를 선언 전에 호출하는 것이 불가능 해지고, 유지보수 관점에서도 해당 함수를 찾기 위해 이리저리 찾으로 다닐 필요 없이 위쪽에서 찾으면 되기 때문에 가독성도 올라간다.

```javascript
const active = () => {
	(....)
}
active()
```

## 4. (참고) hoisting 우선순위

```text
같은 이름의 var 변수 선언 vs 함수 선언에서의 호이스팅
```

같은 이름의 `var`변수와 함수 중에 먼저 호이스팅이 되는 것은 `변수`가 함수선언을 덮어쓴다. 하지만 만약에 변수에 아무 값도 할당이 되어 있지 않다면 함수 선언문이 변수 선언문을 덮어쓰게 된다.

## 5. 정리

ES6 문법인 let / const가 나온 이후로 해당 문법을 사용 하면 호이스팅으로 인한 문제를 해결 할 수 있지만, 아직 많은 오래된 프로젝트들에서 var를 쓰고 있다. 되도록이면 var는 절대! 사용 하지말고 ESNext 문법 사용을 권장한다.
