---
title: Vue cycle과 반응형 데이터 처리
date: '2023-05-09'
tags: ['vue']
draft: false
---

Vue는 MVVM 디자인 패턴으로부터 영감을 받은 프레임워크다.

- Model : 자바스크립트 코드
- View : 우리가 보는 화면
- View Model : 뷰모델은 뷰 인스턴스로 뷰에 필요한 기능과 필드를 가지고, 뷰와 모델의 데이터 바인딩하여 연결해주는 역할을 해준다

![mvvm](https://github.com/Jiyun-Parkk/dev-blog/assets/72537762/646720c0-22af-46c7-a38e-8a48f1a9cdf6)

## Vue의 반응형 데이터, 양방향 데이터 바인딩

Vue에서 가장 특징적인 장점은 양방향 데이터 바인딩이 가능하다는 것인데, 그 이유가 데이터의 변경을 프레임워크에서 감지하고 있다가, 데이터가 변경되는 시점에 DOM 객체에 렌더링을 해주거나 페이지 내에서 모델의 변경을 감지해 JS 실행부에서 변경한다. 입력된 값이나 변경된 값에 따라 내용이 바로 바뀌기 때문에 따로 체크해주지 않아도 된다.

기본적으로 Vue 컴포넌트의 데이터 바인딩 자체는 단방향 바인딩이지만 Vue의 특수한 디렉티브를 사용하면 양방향 데이터 바인딩이 가능하다.

리액트는 변경된 데이터를 적용하려면 변경된 데이터에 관한 처리를 모델과 뷰 모두 수정해주어야 하지만, Vue에서는 ref, reactive을 활용해 데이터를 할당하면, Vue 자체의 기능으로 proxy객체로 감싸지면서 변화에 따른 감지가 가능해지게 된다.

해당 데이터들은 할당과 동시에 observe 기능이 활성화되는데, 이는 실제 내부적으로는 ES5의 getter/setter를 통해 데이터의 변조 및 접근시 별도 로직이 구현되어있기 때문이다. 즉, 데이터가 변경되면, notify 기능을 통해 해당 데이터를 사용하는 View(DOM)를 찾게되고 변경된 데이터를 반영하게 되는 것이다.

## 반응형 데이터 감시하기

### Computed

Computed는 반응형 소스의 계산된 값을 리턴해주는 함수다. 본래 일반적인 함수는 컴포넌트가 렌더링이 될때마다 새롭게 생성이 되지만, computed의 경우에는 이전에 함수가 생성되었던 것을 기억하고 있다가 내부 콜백함수에서 의존하고 있는 반응형 소스의 변경이 있을때마다 재호출 된다.

Computed의 주요 기능은 변경된 반응형 소스 값을 리턴해주는 것이기 때문에, 꼭 리턴값이 필수적으로 필요하다.

### Watch

watch는 세가지 인자값을 받는다

- 감시할 반응형 소스
- 변화가 있을떄 실행할 콜백 함수
- 감시 옵션

watch는 첫번쨰 인자로 받아온 반응형 소스의 데이터가 변경될떄 마다 콜백함수를 실행해준다. computed와 다른 점은 리턴값이 필요하지 않다는 것이고, 세번째 인자인 감시 옵션 설정을 통해 다양한 방식으로 감시를 할 수가 있다.

한가지 대표적인 옵션으로는 immediate 옵션이 있다. 이 값이 true면 별다른 값 변화가 없더라도 최초 렌더링시에 watch가 실행된다.

### WatchEffect

watch의 기본적 기능은 반응형 소스의 변화 감지다. 따라서 최초 렌더링시 코드 실행이 되지 않는데, 위에서 명시한 것처럼 세번쨰 인자 옵션으로 최초 렌더링시 코드를 실행 시킬 수 있다. watchEffect를 사용하면 특별한 옵션 없이도 immediate 옵션과 같이 최초 렌더링시 코드를 실행 시킬 수 있는 기능을 사용 할 수 있다.

그리고 watch와 마찬가지로 콜백함수 내부에 의존성이 있는 반응형 소스의 변화에 따라 코드가 실행된다. wath 와의 차이점은 값을 받는 것이 콜백함수 하나뿐이고, 따로 의존성 소스를 등록하지 않더라도 콜백 함수 내부의 의존성이 있는 반응형 소스 변화에 모두 감지를 한다는 것이다.

만약 많은 반응형 소스에 변화에 따른 코드를 실행하고 싶다면 watchEffect를 적절하게 사용하면 좋을 것 같다. 하지만 하나의 반응형 소스가 변화될때마다 불필요한 코드까지 다시 실행시키는 것은 그다지 효율적으로 보이지 않아서, watch로 적절히 분리하여 처리하는 것이 옳을 듯 하다.

## Vue는 SPA, 가상 돔

Vue는 위와 같은 방법들을 사용하여 데이터를 변경하면, 데이터가 변경된 일부분만 재렌더링이 된다. 왜냐하면 Vue는 가상 Dom객체를 Javascript로 구성하고 있어서, 실제 Dom과 가상 Dom을 서로 비교하여 변경된 부분만 찾아내어 변경하기 때문이다.

기존 방식의 렌더링은 하나의 변화가 있으면 처음부터 끝까지 다시 서버에 페이지를 요청하고 렌더링 해야 했지만, Vue는 변경된 부분만 렌더링하기 때문에 데이터 변경시 성능에 있어서 훨씬 경제적이다.

이렇게 변경된 부분만 다시 렌더링 하는 것은 서버쪽으로 다시 페이지를 요청하는 것이 아니라, 클라이언트 측에서 데이터의 변화에 따라 돔 객체를 갈아끼워 화면 렌더링만 변경시키는 것이므로 결국에는 하나의 페이지로 모든 컨텐츠를 렌더링 해주고 있는 것이다.

따라서 Vue가 SPA로 프론트개발을 할 수 있는 프레임워크 인 것이다.

웹사이트의 규모가 점점 커짐에 따라 클라이언트 측에서 변경 처리를 해야 하는 데이터들도 많아졌기 떄문에, Vue, React와 같은 SPA 개발 툴이 각광받고 있지만 규모가 작은 페이지에서는 오히려 Vue, React를 사용하는 것이 독이 될 수 있으니 상황에 따라 맞춰 쓰면 된다.

## Vue의 단점

위와 같은 장점들이 있지만, 최종적으로 프로젝트를 빌드하면 소스 코드가 하나로 합쳐지면서 파일 용량이 매우 커진다. 따라서 초기 렌더링이 MPA 방식보다 오래걸린다는 단점이 있다. (대신에 한번 로드된 이후에는 페이지 전환이 MPA보다 빠르다는 이점이 있다)

## lazy load

만약 초기 렌더링 속도를 잡고 싶다면 component 렌더링시 lazy load option을 주면 최초에 모든 소스를 불러오는 것이 아니라 컴포넌트가 렌더링 될때만 소스를 가져오도록 하면 초기 렌더링 시간을 조금 감소시킬 수 있다.

lazy load로 컴포넌트를 불러오면 prefech로 미리 리소스를 캐시에 저장하고 컴포넌트가 렌더링 되어야 할때 캐시에 저장된 데이터를 가져와 렌더링 한다. 하지만 이 방법을 사용하게 되면, prefetch의 chunk 데이터가 계속해서 request가 되기 때문에 오히려 성능상 좋지 않을 수 있다.

따라서 lazy load 모드는 컴포넌트의 변화가 잦지 않고 사용자가 자주 찾지 않은 화면에서 사용하는 것이 좋다.

[MPA / SPA / CSR / SSR](https://www.junedevblog.com/blog/web/csr&ssr)
